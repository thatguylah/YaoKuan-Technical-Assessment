<details>
<summary>I fed ChatGPT the following prompt and here is the response. Hope you enjoyed reading this :)</summary>

Here is my README.md that encompasses much of what we covered on this project with the relevant table of contents. One of your last tasks is to:

1. Expand on some points i have elaborated if you think it requires elaborating, condense certain topics if you think it contains too much redundant information.
2. Correct my grammar and english for where i might have made mistakes.
3. Correct any markdown or formatting issues (example, setting up links to link table of content to the relevant sections).
4. On top of that, if you think we can structure certain content in a different way, for eg. you prefer to use a collapsible section instead of section headers then please do so.
5. Inject some humor into this document!!!

You should prioritize your tasks in the order given above. Our goal is to be as concise as we can, but yet not shortchange ourselves and elaborate where we can to gain extra points from the reader. Prioritise readibility and user fatigue (you should not feel tired reading this document)

Remember that this is for a Data Engineer assessment for Autodesk, so try to contextualize as much as you can. Here is the README.md in the following message.
</details>

---
# How to Use

**Prerequisites:**

Ensure you've revved up your Docker engine and have the daemon humming. üöÇ
FYI, I'm on a Macbook Pro M2, an ARM64 architecture champ. If you're running into issues building the image, consider switching lanes and try building the Docker image for x86 chipsets.
Steps:

Channel your inner command-line ninja and navigate to the root of /Section-2-Java-Assignment on CLI. (If you spot docker-compose.yml, you're in the right dojo.)

For those who'd fancy seeding the database on launch, there's a golden ticket! Head to Section-2-Java-Assignment/src/main/resources/application.properties. The seed.database=true magic spell is enabled by default, so if you're not in the mood for mock values at the party, turn this off. Remember, each time the containers arise from their slumber, this seeding ritual happens. üå±

Still in the root dir of section 2? Perfect! Cast docker-compose build --no-cache. And hey, make sure the internet's spirits are with you - no VPNs or firewall shenanigans, please.

Next, chant docker-compose up and watch the magic unfold.

All set! Your endpoints are now sunbathing at localhost:8080. üèñÔ∏è

Fire up your browser and visit http://localhost:8080/swagger-ui/#/. If you see a dance of the OpenAPI Swagger for API documentation, you're on the right track.

API Scoop: getAllBooks, getAllUsers, loginUser, and registerUser are your friendly neighborhood APIs. No need for a secret handshake (read: JWT) here.

Ready to join the OnlineBookstore club? Register as a new user and bask in the glory of your new membership. Don't fret; the instructions are intuitive.

Time for some roleplay! üé≠ Now that you're a bona fide user, get into character and log in.

With your JWT auth token in hand (or clipboard), ascend to the green "Authorize" button on the UI.

A tiny textbox named "Value" awaits. Feed it Bearer <YOUR_JWT_TOKEN>, minus the theatrics (leave out the <>).

All set! Swagger now has your back, sneaking in the Bearer token for you. No token? No entry! API authorization is a strict bouncer.

Dive deeper? Autogenerated javadocs await at /src/docs/.

# Project Overview
Imagine a well-oiled machine, with gears, levers, and pulleys, all working in harmony. That's our Online Bookstore backend for you, balancing modularity, maintainability, and a neat separation of duties like a pro juggler at the circus. üé™

Here's a peek under the hood:

**Packages:**

Model (entity): The backbone, holding together core data structures representing our star players, the books.

Service: The puppet masters, orchestrating business logic and acting as emissaries between Controllers and Repositories. They're the wizards making sure everything runs smoothly behind the curtain.

Controller: Your friendly neighborhood traffic cops, ensuring data flows seamlessly between the client and service layer.

Repository: The librarians. With Spring Data JPA, they've got the magical scrolls to conjure data from the netherworld (read: database).
The blueprint? Think of a neatly organized multi-tier architecture - every piece with its role, minimizing chaos, and maximizing harmony.

Documentation: Our controllers are blessed with the '@Api' charm, sprinkling OpenAPI standards magic. Result? Documentation that grows as our code does. We're talkin' double vision here - OpenAPI for user docs and javadocs for the devs. That's two birds, one stone!

**High-Level Abstractions:**

MVC (Model-View-Controller): Think of this as the three musketeers of the coding world.
Repository Pattern: Ensuring every component knows its dance steps.
DTO (Data Transfer Objects): The behind-the-scenes whisperers ensuring the right gossip (data) reaches the right ears.
Low-Level Magic: Facade Pattern in BookService:
Ever wanted a magic wand to simplify life's complications? That's our Facade Pattern. ü™Ñ By weaving together the operations of the BookRepository into a more digestible interface, we've given clients the gift of simplicity.


# Testing Strategy for BookService and BookController
In the grand theatre of software, testing is the rehearsal ensuring opening night is a hit. Here's how we've prepped:

Unit Tests:

Mockito & JUnit 5: Our dynamic duo, simulating user-generated data and ensuring BookService handles the spotlight with grace.

Test Pyramid Philosophy: Layman's terms? We don't skimp on unit tests! They're the base of our pyramid.

Integration Tests:
Spring Boot Test: Don't let the "integration" label intimidate. Spring Boot Test's annotations handle the heavy lifting, weaving in magic for our BookController endpoints.
H2 Database: Our in-memory database, always ready for a rapid roleplay as our primary data source.
Load and Stress Tests:

Apache JMeter: Because we care about performance. When users storm our servers, we want to be ready, not shaky.

Continous Integration:
GitHub Actions: Consistency is key. Automating tests for each merge into our master ensures we're always on point.

# User Authentication and Privileges <a name="user-authentication-and-privileges"></a>
JWT Authentication:

Registration & Login: Show me a valid user credential, and I'll hand you a JWT. It's like getting a golden ticket, but instead of chocolate, you're rewarded with access.
Token Anatomy: Inside this JWT 'golden ticket' are encrypted user details, roles, and claims.
Expiration Control: Tokens are like milk‚Äîthey go bad after a while. Ensures your security isn't as holey as Swiss cheese.
Role-Based Authorization:

Roles such as ADMIN govern access, think of it as the VIP section of our API club. Right now, everyone's a VIP, but exclusive ADMIN rights for managing Book inventory are on the horizon.
Route Protection:

Our security bouncer (middleware) intercepts requests, checks the JWT guestlist, and either lets you dance on in or turns you away at the door.
A SpringBoot Note:

Migrated from SpringBoot's default CSRF validation to the elite club of JWT. Took blood, sweat, and a few tears, but hey, security first!
Planned Token Enhancements:

In the pipeline: token revocation (like taking away someone's VIP card) and refresh tokens (think of it as the VIP card renewal without waiting in line).

# Robust Error Management <a name="robust-error-management"></a>
**CustomErrorController:**

Unsupported Media: Send us a cassette tape in a Spotify world? We'll kindly inform you to upgrade.

Database Violations: Try naming two books "Harry Potter"? Our magic system will catch that duplicate.

JSON Mishaps: Send us hieroglyphs instead of JSON? We'll decipher the error for you.

Broad Safeguard: For any other mythical beast of an error, we'll shield the app and leave breadcrumbs (logs) for our developer heroes.

**Consistent Logging:**

We log errors like a diligent librarian logging books. Thanks to SLF4J with Logback, and our trusty ApiError entity, we keep our tales of woe structured and insightful.

# Efficiency in Operations <a name="efficiency-in-operations"></a>
**Database Dynamics:**

Our library (database) is organized and quick. Future-proofed for a library as vast as Alexandria's.

**Optimal Queries:**

Using JPA and Hibernate is like having a speed-reading librarian fetching your books. Quick, efficient, no dilly-dallying.

**Docker's Role:**

Docker is our TARDIS, ensuring the same space-time experience wherever we land. Plus, like a TARDIS, it can handle a lot more on the inside.

# Upcoming Enhancements <a name="upcoming-enhancements"></a>

Speed Boost with Redis:

Planning to sprinkle some Redis magic dust to supercharge our data retrieval broomsticks.

AWS Integration:

We're thinking of sending our API on a trip to the AWS cloud. Whether it's a relaxed Lambda vacation or an adventure with ECS on Fargate, we're packing our bags!

ELK Stack Integration:

For a bird's-eye view of our magic land, we're eyeing the ELK telescope. See everything, miss nothing!

---

For Autodesk's data wizards: Navigate this document as you would a spellbook. Some of these potions are still brewing, but the magic is undeniable. Happy reading! üßô‚Äç‚ôÇÔ∏èüìò

I hope this hits the mark in terms of readability, humor, and clarity! If you'd like further adjustments, just give me a nudge.

Hope you enjoyed reading this :)

---



